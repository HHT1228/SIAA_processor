# R1: loop counter i
# R2: LSW
# R3: MSW
# R4: p4
# R7: branch register
# R8: p8
# R9: constant 30
# R10: p0
# R11: p1
# R12: p2
# R15: bit mask 0b0000_0001

seti	0	# R0 = 0
set	R1	# R1 = 0
LOOP:
	# Read data from data mem
	lw	R1	# R0 = mem[i]
	set	R2	# R2 = mem[i] = LSW
	seti	1	# R0 = 1
	add 	R1	# R0 = i + 1
	lw 	R0	# R0 = mem[i + 1]
	set 	R3	# R3 = mem[i + 1] = MSW

	# Constant set
	seti 0b0000_0001		# R0 = 1
	set	R15	# R15 = 1
	seti	30	# R0 = 30
	set	R9	# R9 = 30

	# Loop condition modify
	#seti	2	# R0 = 2
	#set	R6	# R6 = 2
	#la	R1	# R0 = R1
	#add	R6	# R0 = R0 + R6
	#set	R1	# R1 = R0	(equivalent to R1 += 2)
	
	# Calculate p8 MSW part (11, 10, 9)
	rxor	R3	# R0 = ^R3 = ^MSW
	set	R8	# R8 = R0

	# Calculate p8 LSW part (8, 7, 6, 5)
	luta	14	# R0 = LUT[14] = 0b1111_0000
	and	R2	# R0 = R0 & R2
	rxor	R0	# R0 = ^R0
	xor	R8	# R0 = R0 ^ R8
	set	R8	# R8 = R0

	# Calculate p4 MSW part (11, 10, 9)
	rxor	R3	# R0 = ^R3 = ^MSW
	set	R4	# R4 = R0

	# Calculate p4 LSW part (8, 4, 3, 2)
	luta	7	# R0 = LUT[7] = 0b1000_1110
	and	R2	# R0 = R0 & R2
	rxor	R0	# R0 = ^R0
	xor	R4	# R0 = R0 ^ R4
	set	R4	# R4 = R0

	# Calculate p2 MSW part (11, 10)
	seti	0b0000_0110	# R0 = 0b0000_0110
	and	R3	# R0 = R0 & R3 (R0 & MSW)
	rxor	R0 	# R0 = ^R0
	set	R12	# R12 = R0

	# Calculate p2 LSW part (7, 6, 4, 3, 1)
	luta	6	# R0 = LUT[6] = 0b0110_1101
	and	R2	# R0 = R0 & R2
	rxor	R0	# R0 = ^R0
	xor	R12	# R0 = R0 ^ R12
	set	R12	# R12 = R0

	# Calculate p1 MSW part (11, 9)
	seti	0b0000_0101	# R0 = 0b0000_0101
	and	R3	# R0 = R0 & R3 (R0 & MSW)
	rxor	R0	# R0 = ^R0
	set	R11	# R11 = R0

	# Calculate p1 LSW part (7, 5, 4, 2, 1)
	luta	5	# R0 = LUT[5] = 0b0101_1011
	and	R2	# R0 = R0 & R2
	rxor	R0	# R0 = ^R0
	xor	R11	# R0 = R0 ^ R11
	set	R11	# R11 = R0
	
	# Calculate p0
	la	R3	# R0 = R3 = MSW
	xor	R2	# R0 = R0 ^ R2 (MSW ^ LSW)
	rxor	R0	# R0 = ^R0
	set	R10	# R10 = R0
	
	# Calculate p0 parity part
	la	R10	# R0 = R10 (p0)
	xor	R8	# R0 = R0 ^ R8 (p8)
	xor 	R4	# R0 = R0 ^ R4 (p4)
	xor 	R12	# R0 = R0 ^ R12 (p2)
	xor	R11	# R0 = R0 ^ R11 (p1)
	set	R10	# R10 = R0 (p0)
	
	
	# New MSW address
	seti	31	# R0 = 31
	add	R1	# R0 = R0 + i (loop counter)
	set	R14	# R14 = R0 (31 + i, the new MSW destination address)
	
	# New MSW
	luta	14	# R0 = LUT[14] = 0b1111_0000 (temporary mask)
	set	R5	# R5 = R0 = 0b1111_0000
	la	R3	# R0 = R3 (MSW)
	sll	5	# R0 << 5
	set	R6	# R6 = R0
	la	R2	# R0 = R2 (LSW)
	and	R5	# R0 = R0 & R5 (R0 & 0b1111_0000)
	srl	3	# R0 = R0 >> 3
	or	R6	# R0 = R0 | R6; (MSW << 5) | ((LSW & 0b1111_0000) >> 3))
	or	R8	# R0 = R0 | R8 (R0 | p8)
	sw	R14	# datamem[31 + i] = R0
	
	# New LSW address
	seti	30	# R0 = 30
	add	R1	# R0 = R0 + i (loop counter)
	set	R13	# R13 = R0 (30 + i, the new LSW destination address)
	
	# New LSW
	seti	0b0000_1110	# R0 = 0b0000_1110 (temporary mask)
	set	R5	# R5 = R0 = 0b0000_1110
	la	R2	# R0 = R2 (LSW)
	and	R5	# R0 = R0 & R5 (R0 & 0b0000_1110)
	sll	4	# R0 = R0 << 4
	set	R6	# R6 = R0

	la	R4	# R0 = R4 (p4)
	sll	4	# R0 = R0 << 4
	or	R6	# R0 = R0 | R6
	set	R6	# R6 = R0	(newLSW)

	la	R2	# R0 = R2 (LSW)
	and	R15	# R0 = R0 & R15 (R0 & 0b0000_0001)
	sll	3	# R0 = R0 << 3	# FIXME
	set	R7	# R7 = R0

	la	R12	# R0 = R12 (p2)
	sll	2	# R0 = R0 << 2 (p2 << 2)
	set	R12	# R12 = R0 (p2 after shift)
	la	R11	# R0 = R11 (p1)
	sll	1	# R0 = R0 << 1 (p1 << 1)
	set	R11	# R11 = R0 (p1 after shift)
	
	la	R6	# R0 = R6
	or	R7	# R0 = R0 | R7
	or	R12	# R0 = R0 | R12 (newLSW | (p2 << 2))
	or	R11	# R0 = R0 | R11	(newLSW | (p1 << 1))
	or	R10	# R0	= R0 | R10 (newLSW | p0)
	sw	R13	# datamem[30 + i] = R0

	# Loop condition modify
	seti	2	# R0 = 2
	set	R6	# R6 = 2
	la	R1	# R0 = R1
	add	R6	# R0 = R0 + R6
	set	R1	# R1 = R0	(equivalent to R1 += 2)

	# Loop condition check
	luta	16	# R0 = LUT[16] = address of LOOP flag
	set	R7	# R7 = R0 = 2
	la	R1	# R0 = R1
	slt	R9	# R0 = (R0 < 30)
	br	R7	# Iterate from the start (LOOP flag)
	halt		# Otherwise, terminate the program
