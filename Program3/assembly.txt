# R1: loop counter i, index of mem (33, 34, 35)
# R2: pattern
# R3: mem_33, mem_35
# R4: mem_34
# R5: equal, branch register
# R6: loop boundary 32
# R7: store mem[i]
# R8: store mem[i+1]
# R9: occNum
# R10: loop counter j
# R11: loop boundary for j
# R12: curr_5bit1
# R13: curr_5bit2, curr_5bit
# R14: shifting number

luta	0	# R0 = LUT[0] = 32
set	R6	# R6 = 32 (loop boundary)
lw	R0	# R0 = mem[32]
srl	3	# R0 = mem[32] >> 3
set	R2	# R2 = mem[32] >> 3 (pattern)

seti	0	# R0 = 0
set	R1	# R1 = 0 (loop counter i)

set	R3	# R3 = mem_33
set	R4	# R4 = mem_34

LOOP1_part_a:
  seti	0	# R0 = 0
  set	R9	# R9 = 0 (occNum)
  lw	R1	# R0 = mem[i]
  set	R7	# R7 = mem[i] (currByte)
  seti	0	# R0 = 0
  set	R10	# R10 = 0 (loop counter j)
  seti	4	# R0 = 4
  set	R11	# R11 = 4 (loop boundary j)
	
LOOP1_J_loop:
  seti	0b0001_1111	# R0 = 0b0001_1111
  and	R7	# R0 = R0 & R7 = 0b11111 & currByte = curr_5bit
  eq	R2	# R0 = R0 == R2 = curr_5bit == pattern = equal
  set	R5	# R5 = equal
  add	R9	# R0 = equal + R9 (occNum)
  set	R9	# R9 = R0 (occNum)
  la	R5	# R0 = equal
  add	R3	# R0 += R3 (mem_33)
  set	R3	# R3 = R0 (mem_33)
  la	R7	# R0 = currByte
  srl	1	# R0 = currByte >> 1
  set	R7	# currByte >>= 1

  luta	25	# R0 = LUT[25] = address of LOOP1_J_loop
  set	R5	# R5 = R0
  seti	1	# R0 = 1
  add	R10	# R0 = R10 + 1 = new j
  set	R10	# R10 = R0
  slt	R11	# R0 = R0 < R11 = new j < 4
  br	R5	# go to LOOP1_J_loop

LOOP1_part_b:
  seti	0	# R0 = 0
  slt	R9	# R0 = (R0 < R9) = (occNum > 0)
  add	R4	# R0 = R4 + (occNum > 0)
  set	R4	# R4 = R0

  luta	24	# R0 = LUT[24] = address of LOOP1_part_a
  set	R5	# R5 = R0
  la	R1	# R0 = R1 (i)
  addi	1	# R0 = i + 1 = new i
  set	R1	# R1 = R0 = new i
  slt	R6	# R0 = R0 < R6 = new i < 32
  br	R5	# go to LOOP1_part_a

after_LOOP1:
  luta	1	# R0 = LUT[1] = 33
  set	R1	# R1 = 33
  la	R3	# la mem_33 to R0
  sw	R1 	# mem[R1] = R0, mem[33] = mem_33

  luta	2	# R0 = LUT[2] = 34
  set	R1	# R1 = 34
  la	R4	# la mem_34 to R0
  sw	R1 	# mem[R1] = R0, mem[34] = mem_34

  seti	0	# R0 = 0
  set	R1	# loop counter i = 0
  set	R3	# R3 = mem_35 = 0

LOOP2_part_a:
  lw	R1	# R0 = mem[i]
  set	R7	# R7 = mem[i] (mem_i)

  seti	1	# R0 = 1
  add	R1	# R0 = i + 1
  lw	R0	# R0 = mem[i+1]
  set	R8	# R8 = mem[i+1] (mem_i1)

  seti	7	# R0 = 7
  set	R10	# R10 = 7 (loop counter j)

  seti	0	# R0 = 0
  set	R11	# R11 = 0 (loop boundary j)

LOOP2_J_loopA:
  luta	28	# R0 = LUT[28] = address of LOOP2_J_loopInByte
  set	R5	# R5 = R0
  seti	3	# R0 = 3
  slt	R10	# R0 = R0 < R10 = 3 < j = j > 3
  br	R5	# if j > 3, in byte

  luta	30	# R0 = LUT[30] = address of LOOP2_part_b
  set	R5	# R5 = R0
  seti	31	# R0 = 31
  eq	R1	# R0 = (i == 31)
  br	R5	# no more, jump out of the j loop

  seti	0b0000_1111	# R0 = 0b0000_1111
  set	R12	# R12 = curr_5bit1 = 0b1111
  seti	3	# R0 = 3
  sub	R10	# R0 = 3 - j
  set	R14	# R14 = shifting number = 3 - j
  la	R12	# R0 = 0b1111
  srr	R14	# R0 = 0b1111 >> 3 - j
  and	R7	# R0 = R0 & mem_i
  set	R12	# R12 = curr_5bit1 = (0b1111 >> 3 - j) & mem_i
  seti	1	# R0 = 1
  add	R14	# R14 = 4 - j
  la	R12	# R0 = curr_5bit1
  slr	R14	# R0 = curr_5bit1 << 4 - j
  set	R12	# R12 = curr_5bit1

  seti	0b0000_1111	# R0 = 0b0000_1111
  set	R13	# R13 = curr_5bit2 = 0b1111
  la	R13	# R0 = 0b1111
  srr	R10	# R0 = 0b1111 >> j
  set	R13	# R13 = 0b1111 >> j
  seti	4	# R0 = 4
  add	R10	# R0 = j + 4
  set	R14	# R14 = j + 4
  la	R13	# R0 = curr_5bit2
  slr	R14	# R0 = curr_5bit2 << j + 4
  and	R8	# R0 = curr_5bit2 << j + 4 & mem_i1
  srr	R14	# R0 = ((curr_5bit2 << j + 4) & mem_i1) >> j + 4
  set	R13	# R13 = curr_5bit2

  la	R12	# R0 = curr_5bit1
  add	R13	# R0 = curr_5bit1 + curr_5bit2
  set	R13	# R13 = curr_5bit = curr_5bit1 + curr_5bit2

  luta	29	# R0 = LUT[29] = address of LOOP2_J_loopB
  j	R0

LOOP2_J_loopInByte:
  seti	0b0001_1111	# R0 = 0b0001_1111
  set	R13	# R13 = 0b11111
  la	R10	# R0 = j
  subi	4 	# R0 = j - 4
  set	R14	# R14 = shifting number = j - 4
  la	R13	# R0 = R13
  slr	R14	# R0 = R0 << R15 = 0b11111 << (j - 4)
  and	R7	# R0 = R0 & R7 = curr_5bit & mem_i = curr_5bit
  srr	R14	# R0 = curr_5bit >> (j - 4)
  set	R13	# R13 = curr_5bit

LOOP2_J_loopB:
  la	R2	# R0 = R2 = pattern
  eq	R13	# R0 = pattern == curr_5bit
  set	R5	# R5 = R0
  la	R3	# R0 = R3 = mem_35
  add	R5	# R0 = mem_35 + (pattern == curr_5bit)
  set	R3	# R3 = R0 (mem_35)

  luta	30	# R0 = LUT[30] = address of LOOP2_part_b
  set	R5	# R5 = R0
  seti	0	# R0 = 0
  eq	R10	# R0 = R10 == 0 = j == 0
  br	R5	# go out of the j loop

  la	R10	# R0 = j
  subi	1	# R0 = j - 1
  set	R10	# R10 = j = j - 1
  luta	27	# R0 = LUT[27] = address of LOOP2_J_loopA
  j	R0

LOOP2_part_b:
  luta	26	# R0 = LUT[26] = address of LOOP2_part_a
  set	R5	# R5 = R0
  la	R1	# R0 = R1 (i)
  addi	1	# R0 = i + 1 = new i
  set	R1	# R1 = R0 = new i
  slt	R6	# R0 = R0 < R6 = new i < 32
  br	R5	# go to LOOP2_part_a

after_LOOP2:
  luta	3	# R0 = LUT[3] = 35
  set	R1	# R1 = 35
  la	R3	# la mem_35 to R0
  sw	R1 	# mem[R1] = R0, mem[35] = mem_35

  halt	# terminate
